## 聊聊应用场景
最近再做一个会员中心。有这样两个场景被我套用了工厂模式以及抽象工厂模式。

1.会员拥有积分属性，积分有对应的发放操作、扣减操作、回退操作。

2.会员需要进行会员权益的发放，权益可能是优惠卷，积分，折扣，积分倍率发放等不同的权益。
## 积分操作场景
    该业务场景我使用了工厂模式。
![](http://blog.jiazhiwei.net/assets/img/AbstractFactoryDesign.png)

定义了统计的operation接口,该接口规定了统一的操作方法交由子类实现。具体使用哪个操作类交由工厂类IntegralOperationFactory来进行控制。
根据调用放传来的不同的操作类型,工厂进而生成不同的积分操作类。然后再由积分服务去执行operation方法中定义的operate方法即可。
这样做的好处显而易见，拆分了原本需要if else来编写的一长串代码，有新的操作时只需要新增一个实现operation接口的operation类，同时在工厂中
新增对应操作类的实例即可（这一步其实可以利用反射或者spring容器做的更加通用化）。

## 会员权益发放场景
该业务使用了抽象工厂模式。
![](http://blog.jiazhiwei.net/assets/img/AbstractFactoryDesign.png)

我认为抽象工厂模式与工厂方法模式十分的相似。所不同的是工厂方法生产一类对象，就如积分业务场景，积分工厂生产的对象本质上都是对积分的一个操作。
而这里的权益场景则不同，虽然他们都属于会员的一个权益，但是具体到每个权益的内容却是不同。积分权益是发放积分，新人卷权益是发放优惠卷，积分倍率
权益是修改会员的积分倍率，折扣权益是修改会员的折扣。这些权益有公共的部分，细节上确是大不相同。因此我们通过统一的抽象类BaseBenefit将公共的
逻辑给抽象出来（权益发放都需要对会员表进行处理，并需要加锁的保存),不同的部分定义好方法，交由具体的子类去实现，通过BenefitFactory来根据不同
的权益配置生成不同的权益，再由各个权益的doGrantBenefit来出发权益的具体发放。
    
我看到很多说法说抽象工厂是工厂的工厂.套用这句话来对该业务进行解读，BenefitFactory根据不同的权益配置生成了不同的权益工厂，例如积分权益工厂，
优惠卷权益工厂，积分倍率权益工厂，会员折扣权益工厂。这些工厂都有统一的权益发放方法doGrantBenefit来触发权益发放。

而针对积分业务场景来说，都是对积分的操作，所以我们不能说积分发放的工厂，积分回退的工厂，这是不合理的。
